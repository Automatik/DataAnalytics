import dash
import dash_table
import dash_html_components as html
import dash_core_components as dcc
from dash.dependencies import Input, Output, State
import flask
import pandas as pd
import plotly.graph_objs as go
import glob
import os 
import plotly

df = pd.read_csv('../Dati/Tw_gg.csv')
df2 = pd.read_csv('../Dati/Username.csv')
df3 = pd.read_csv('../Dati/Dettaglio.csv')
df4 = pd.read_csv('../Dati/JST.csv', sep = ";")
df4 = df4.sort_values("topic")
image_directory = '../Dati/UserWordCloud//'

list_of_images = [os.path.basename(x) for x in glob.glob('{}*.jpg'.format(image_directory))]
static_image_route = '/static/'

external_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']

app = dash.Dash(__name__, external_stylesheets=external_stylesheets)
app.config['suppress_callback_exceptions']=True  #If you are assigning callbacks to components that are generated by other callbacks (i miei grafici a torta)
                                                    #(and therefore not in the initial layout), then
                                                    #you can suppress this exception by setting
                                                    #`app.config['suppress_callback_exceptions']=True`.
#suddivisione pagina in tab
def serve_layout():

    # send initial layout if there is flask request context
    if flask.has_request_context():
        return layout_index

    # otherwise send every element to dash validator to prevent callback exceptions
    return html.Div([
        layout_index,
        layout_tab_1,
        layout_tab_2,
    ])

tabs_styles = {
    'height': '44px'
}
tab_style = {
    'borderBottom': '1px solid #d6d6d6',
    'padding': '6px',
    'fontWeight': 'bold'
}

tab_selected_style = {
    'borderTop': '1px solid #d6d6d6',
    'borderBottom': '1px solid #d6d6d6',
    'backgroundColor': '#119DFF',
    'color': 'white',
    'padding': '6px'
}

layout_index = html.Div([
    dcc.Tabs(id="tabs", value='tab-1', children=[
        dcc.Tab(label='Pagina', value='tab-1'),
        dcc.Tab(label='Pubblico', value='tab-2', children=[
            dcc.Tabs(id="subtabs", value="subtab1", children = [
                dcc.Tab(label='Panoramica', value="subtab1",style=tab_style, selected_style=tab_selected_style),
                dcc.Tab(label='Dettaglio', value="subtab2",style=tab_style, selected_style=tab_selected_style)
                        ])
        ]),
        dcc.Tab(label='Sentiment', value='tab-3'),
    ]),
    html.Div(id='tabs-content')])

#layout con grafico per i tweet
layout_tab_1 = html.Div([
    dash_table.DataTable(
        id='datatable-interactivity',
        columns=[
            {"name": i, "id": i, "deletable": True} for i in df.columns
        ],
        data=df.to_dict('records_Pagina'),
        editable=True,
        filtering=True,
        sorting=True,
        sorting_type="multi",
        row_selectable="multi",
        row_deletable=True,
        selected_rows=[],
        pagination_mode="fe",
        pagination_settings={
            "current_page": 0,
            "page_size": 5,
        },
    ),
    html.Div(id='datatable-interactivity-container')
])

layout_tab_2 = html.Div([
    dash_table.DataTable(
        id='datatable-interactivity-2',
        columns=[
            {"name": i, "id": i, "deletable": True} for i in df2.columns
        ],
        data=df2.to_dict('records_Pubblico'),
        editable=True,
        filtering=True,
        sorting=True,
        sorting_type="multi",
        row_selectable="multi",
        row_deletable=True,
        selected_rows=[],
        pagination_mode="fe",
        pagination_settings={
            "current_page": 0,
            "page_size": 5,
        },
    ),
    html.Div(id='datatable-interactivity-container-2'),
    
])

available_indicators = df3['Username'].unique()

layout_subtab_2 = html.Div([

        html.Div([
            dcc.Dropdown(
             id='crossfilter-xaxis-column',
             options=[{'label': i, 'value': i} for i in available_indicators],
             value=available_indicators[0]),
             ], style={'verticalAlign': 'top', 'width': '10%'}),


    html.Div([
        dcc.Graph(
                id='crossfilter-indicator-pie')
             ], style={'width': '30%', 'display': 'inline-block'}),
    
    html.Div([
        dcc.Graph(
                id='crossfilter-indicator-pie2')
             ], style={'width': '30%', 'display': 'inline-block'}),
    
    html.Div([
        dcc.Graph(
                id='crossfilter-indicator-pie3')
             ], style={'width': '30%', 'display': 'inline-block'}),

    html.Div([
            dcc.Graph(id = 'countryMap')
        ], style={'width': '55%','display': 'inline-block'}),

    html.Div([
        html.Img(id='image',style={
                'height': '450px',
                'width': '600px'
            })], style={'width': '40%','display': 'inline-block'})
 
])

y_indicators = ["Train","Test"]
x_indicators = ["topic","iterazioni","word","beta"]
word_indicators = df4['word'].unique()
beta_indicators = df4['beta'].unique()
layout_tab_3 = html.Div([

        html.Div([html.Div([
            html.H6("  y value"),
            dcc.Dropdown(
             id='crossfilter-train-test',
             options=[{'label': i, 'value': i} for i in y_indicators],
             value=y_indicators[0]),
             ], style={'verticalAlign': 'top', 'width': '10%','display': 'inline-block'}),

        html.Div([
            html.H6("  word"),
            dcc.Dropdown(
             id='crossfilter-word',
             options=[{'label': i, 'value': i} for i in word_indicators],
             value=word_indicators[0]),
             ], style={'verticalAlign': 'top', 'width': '10%','display': 'inline-block'}),

        html.Div([
            html.H6("  beta"),
            dcc.Dropdown(
             id='crossfilter-beta',
             options=[{'label': i, 'value': i} for i in beta_indicators],
             value=beta_indicators[0]),
             ], style={'verticalAlign': 'top', 'width': '10%','display': 'inline-block'}),

        html.Div([
            html.H6("  x value 1"),
            dcc.Dropdown(
             id='crossfilter-x',
             options=[{'label': i, 'value': i} for i in x_indicators],
             value=x_indicators[0]),
             ], style={'verticalAlign': 'top', 'width': '10%','display': 'inline-block'}),

        html.Div([
            html.H6("  x value 2"),
            dcc.Dropdown(
             id='crossfilter-x-2',
             options=[{'label': i, 'value': i} for i in x_indicators],
             value=x_indicators[1]),
             ], style={'verticalAlign': 'top', 'width': '10%','display': 'inline-block'}),
        ], style={'width': '80%'}),

        html.Div([
        dcc.Graph(
            id='graph-scatter',
            hoverData={'points': [{'customdata': '0'}]}
        )
            ], style={'width': '49%', 'display': 'inline-block'}),

        html.Div([
         dcc.Graph(
            id='graph-b-hover',
        ),

        dcc.Graph(
            id='graph-w-hover',
        )
            ], style={'width': '49%', 'display': 'inline-block'}),

])


app.layout = serve_layout

# Index callbacks
@app.callback(Output('tabs-content', 'children'),
              [Input('tabs', 'value'),
               Input('subtabs', 'value')])
def render_content(tab,subtab):
    if tab == 'tab-1':
        return layout_tab_1
    elif tab == 'tab-3':
        return layout_tab_3
    elif tab == 'tab-2':
        if subtab == "subtab1":
            return layout_tab_2
        elif subtab == "subtab2":
            return layout_subtab_2
        


# Tab 1 Callbacks
@app.callback(
    Output('datatable-interactivity-container', "children"),
    [Input('datatable-interactivity', "derived_virtual_data"),
     Input('datatable-interactivity', "derived_virtual_selected_rows")])
def update_graphs(rows, derived_virtual_selected_rows):
    # When the table is first rendered, `derived_virtual_data` and
    # `derived_virtual_selected_rows` will be `None`. This is due to an
    # idiosyncracy in Dash (unsupplied properties are always None and Dash
    # calls the dependent callbacks when the component is first rendered).
    # So, if `rows` is `None`, then the component was just rendered
    # and its value will be the same as the component's dataframe.
    # Instead of setting `None` in here, you could also set
    # `derived_virtual_data=df.to_rows('dict')` when you initialize
    # the component.
    if derived_virtual_selected_rows is None:
        derived_virtual_selected_rows = []

    dff = df if rows is None else pd.DataFrame(rows)
    
    colors = ['#7FDBFF' if i in derived_virtual_selected_rows else '#0074D9'
              for i in range(len(dff))]
    colorsNeg = ['#FF7F7F' if i in derived_virtual_selected_rows else 'EF0202'
              for i in range(len(dff))]
    colorsP = ['#7FFF9F' if i in derived_virtual_selected_rows else '#2ECC71'
              for i in range(len(dff))]
    colorsNeu = ['#C5C5C5' if i in derived_virtual_selected_rows else '#676767'
              for i in range(len(dff))]

    return [
        dcc.Graph(
            #id=column,
            figure={
                "data": [
                    {
                        "x": dff["Data"],
                        "y": dff["Totale"],
                        "type": "bar",
                        "marker": {"color": colors},
                    }
                ],
                "layout": {
                    "xaxis": {"automargin": True},
                    "yaxis": {
                        "automargin": True,
                        "title": {"text": "Tweet giornalieri"}
                    },
                    "height": 250,
                    "margin": {"t": 10, "l": 10, "r": 10},
                },
            },
        ),
        # check if column exists - user may have deleted it
        # If `column.deletable=False`, then you don't
        # need to do this check.
        #for column in ["Totale"] if column in dff

        dcc.Graph(
            #id=column,
            figure={
                "data": [
                    {
                        "x": dff["Data"],
                        "y": dff["negative"],
                        "type": "bar",
                        "marker": {"color": colorsNeg},
                        "name" : "Negativo"
                    },

                    {
                        "x": dff["Data"],
                        "y": dff["positive"],
                        "type": "bar",
                        "marker": {"color": colorsP},
                        "name" : "Positivo"
                    },

                    {
                        "x": dff["Data"],
                        "y": dff["neutral"],
                        "type": "bar",
                        "marker": {"color": colorsNeu},
                        "name" : "Neutrale"
                    }
                ],
                "layout": {
                    "xaxis": {"automargin": True},
                    "yaxis": {
                        "automargin": True,
                        "title": {"text": "Sentiment"}
                    },
                    "height": 250,
                    "margin": {"t": 10, "l": 10, "r": 10},
                },
            },
        )
    ]

# Tab 2 (subtab1) Callbacks
@app.callback(
    Output('datatable-interactivity-container-2', "children"),
    [Input('datatable-interactivity-2', "derived_virtual_data"),
     Input('datatable-interactivity-2', "derived_virtual_selected_rows")])
def update_graphs(rows2, derived_virtual_selected_rows2):
    # When the table is first rendered, `derived_virtual_data` and
    # `derived_virtual_selected_rows` will be `None`. This is due to an
    # idiosyncracy in Dash (unsupplied properties are always None and Dash
    # calls the dependent callbacks when the component is first rendered).
    # So, if `rows` is `None`, then the component was just rendered
    # and its value will be the same as the component's dataframe.
    # Instead of setting `None` in here, you could also set
    # `derived_virtual_data=df.to_rows('dict')` when you initialize
    # the component.
    if derived_virtual_selected_rows2 is None:
        derived_virtual_selected_rows2 = []

    dff2 = df2 if rows2 is None else pd.DataFrame(rows2)
    colors = ['#7FDBFF' if i in derived_virtual_selected_rows2 else '#0074D9'
              for i in range(len(dff2))]

    return [
        dcc.Graph(
            id=column,
            figure={
                "data": [
                    {
                        "x": dff2["Username"],
                        "y": dff2[column],
                        "type": "bar",
                        "marker": {"color": colors},
                    }
                ],
                "layout": {
                    "xaxis": {"automargin": True},
                    "yaxis": {
                        'type' : 'log',
                        "automargin": True,
                        "title": {"text": column}
                    },
                    "height": 250,
                    "margin": {"t": 10, "l": 10, "r": 10},
                },
            },
        )
        # check if column exists - user may have deleted it
        # If `column.deletable=False`, then you don't
        # need to do this check.
        for column in ["Tweet","Follower"] if column in dff2
    ]
       
# subtab2 Callbacks
@app.callback(
Output('crossfilter-indicator-pie', 'figure'),
[Input('crossfilter-xaxis-column', 'value')])

def display_content(user_name):
    dff3 = df3[df3['Username'] == user_name]
    labels = ['Tweet', "Tweet Altrui"]
    values= [int(dff3["TweetTot"]),int(dff3["Differenza"])]
    colors = ['#08A0E9', '#07587F']
    piedata = go.Pie(labels=labels,values=values,marker=dict(colors=colors))
    return {
     "data":[piedata],
        "layout" : {'title' : 'Tweet totali','height': 300,'margin': {'l': 30, 'b': 30, 'r': 30, 't': 60}, "legend" : {'x': 0.77}, "x" : 0.2},
        
    }

@app.callback(
Output('crossfilter-indicator-pie2', 'figure'),
[Input('crossfilter-xaxis-column', 'value')])

def display_content(user_name):
    dff3 = df3[df3['Username'] == user_name]
    labels = ['Tweet', "ReTweet"]
    values= [int(dff3["Tweet"]),int(dff3["RT"])]
    colors = ['#08A0E9', '#FF5733']
    piedata = go.Pie(labels=labels,values=values,marker=dict(colors=colors)) #5EBDFC
    return {
     "data":[piedata],
        "layout" : {'title' : 'Tweet e ReTweet','height': 300,'margin': {'l': 30, 'b': 30, 'r': 30, 't': 60}, "legend" : {'x': 0.77}},
        
    }

@app.callback(
Output('crossfilter-indicator-pie3', 'figure'),
[Input('crossfilter-xaxis-column', 'value')])

def display_content(user_name):
    dff3 = df3[df3['Username'] == user_name]
    labels = ['Neutrale', "Positivo","Negativo"]
    values= [int(dff3["neutral"]),int(dff3["positive"]),int(dff3["negative"])]
    colors = ['#676767', '#2ECC71', '#EF0202']
    piedata = go.Pie(labels=labels,values=values,marker=dict(colors=colors))
    return {
     "data":[piedata],
        "layout" : {'title' : 'Sentiment','height': 300,'margin': {'l': 30, 'b': 30, 'r': 30, 't': 60}, "legend" : {'x': 0.77}},
        
    }

@app.callback(
    Output('countryMap', 'figure'),
    [Input('crossfilter-xaxis-column', 'value')]
)
def returnChoropleth(user_name):
    dff3 = df3[df3['Username'] == user_name]
    data = [
        go.Choropleth(
            locations = dff3['Code'],
            z = [1],
            colorscale = 'Viridis',
            marker = dict(
             line = dict (
                color = 'rgb(0,0,0)',
                width = 2
            )
          )
        ) 
    ]

    layout = go.Layout(
        title = "Country",
        geo = dict(
            center = dict(lon = -22, lat = 42),
            projection = dict(scale = 2.5)
        ),
        margin = {'l': 30, 'b': 30, 'r': 30, 't': 60},
    )

    return go.Figure(data = data, layout = layout)

@app.callback(
    dash.dependencies.Output('image', 'src'),
    [Input('crossfilter-xaxis-column', 'value')])
def update_image_src(user_name):
    return static_image_route + user_name +"_WC.jpg"

@app.server.route('{}<image_path>.jpg'.format(static_image_route))
def serve_image(image_path):
    image_name = '{}.jpg'.format(image_path)
    if image_name not in list_of_images:
        raise Exception('"{}" is excluded from the allowed static files'.format(image_path))
    return flask.send_from_directory(image_directory, image_name)
    


# Tab sentimetn (3) Callbacks
@app.callback(
    Output('graph-scatter', 'figure'),
    [Input('crossfilter-train-test', 'value'),
     Input('crossfilter-x', 'value'),
     Input('crossfilter-word', 'value'),
     Input('crossfilter-beta', 'value'),
     Input('crossfilter-x-2', 'value')])
def update_graph(y_value,x_value,word,beta,x_value2):

    dffwc=df4[df4['word']==word] #word
    dffw=df4[df4['word']!=word]
    dffbc=df4[df4['beta']==beta] #beta

    dffd=dffw[dffw['beta']!=beta] #differenza
    dffu=dffwc[dffwc['beta']==beta] #unione
    dffbc=dffbc[dffbc['word']!=word] #beta selezionate non comuni
    dffwc=dffwc[dffwc['beta']!=beta] #word selezionate non comuni

    return {
        'data': [go.Scattergl(
            x=[dffd[x_value],dffd[x_value2]],
            y=dffd[y_value],
            mode='markers',
            name = 'Restanti',
            customdata=dffd['id'],
            marker={
               # 'color' : 'rgba(152, 0, 0, .8)',
                'size': 15,
                'opacity': 0.5,
                'line': {'width': 0.5, 'color': 'white'},
            }
        ),
        go.Scattergl(
            x=[dffwc[x_value],dffwc[x_value2]],
            y=dffwc[y_value],
            mode='markers', 
            name = 'Word selezionata',   
            customdata=dffwc['id'],
            marker={
                'size': 15,
                'opacity': 0.5,
                'line': {'width': 0.5, 'color': 'white'},
                
            }       
        ),
        go.Scattergl(
            x=[dffbc[x_value],dffbc[x_value2]],
            y=dffbc[y_value],
            mode='markers', 
            name = 'Beta selezionata',   
            customdata=dffbc['id'],
            marker={
                'size': 15,
                'opacity': 0.5,
                'line': {'width': 0.5, 'color': 'white'},
                
            }       
        ),
        go.Scattergl(
            x=[dffu[x_value],dffu[x_value2]],
            y=dffu[y_value],
            name = 'Word e Beta contemporanea',
            mode='markers',
            customdata=dffu['id'],
            marker={
                'size': 15,
                'opacity': 0.7,
                'line': {'width': 0.5, 'color': 'white'},
                
            }
        )
        ],
        'layout': go.Layout(
            xaxis={
                'title': x_value+" "+x_value2,
            },
            yaxis={
                'title': y_value,
            },
            margin={'l': 40, 'b': 100, 't': 50, 'r': 0},
            height=500,
            hovermode='closest'
        )
    }

def create_hover(dff,y_value):
    return {
        'data': [go.Scatter(
            x=dff['beta'],
            y=dff[y_value],
            mode='lines+markers'
        )],
        'layout': {
            'height': 225,
            'margin': {'l': 20, 'b': 30, 'r': 10, 't': 10},
            'title' : "beta"
        }
    }

@app.callback(
    dash.dependencies.Output('graph-b-hover', 'figure'),
    [dash.dependencies.Input('graph-scatter', 'hoverData'),
     Input('crossfilter-train-test', 'value'),
     Input('crossfilter-word', 'value')])
def update_b_graph(hoverData, y_value,word):
    id_ = hoverData['points'][0]['customdata']
    dff = df4[df4['id'] == id_]
    return create_hover(dff, y_value)

@app.callback(
    dash.dependencies.Output('graph-w-hover', 'figure'),
    [dash.dependencies.Input('graph-scatter', 'hoverData'),
     Input('crossfilter-train-test', 'value'),
     Input('crossfilter-word', 'value')])
def update_w_graph(hoverData, y_value,word):
    id_ = hoverData['points'][0]['customdata']
    dff = df4[df4['id'] == id_]
    return create_hover(dff, y_value)

if __name__ == '__main__':
    app.run_server(debug=True)